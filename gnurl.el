;; -*- lexical-binding: t -*-

(defun parse-define-peephole (expr hash &optional tag)
  (unless tag
    (setq tag 'define_peephole))
  (and (consp expr)
       (eq (car expr) tag)
       (let* ((rest (cdr expr))
	      plist)
	 (when (consp (car rest))
	   (setq plist (plist-put plist :pattern (pop rest))))
	 (when (stringp (car rest))
	   (setq plist (plist-put plist :condition-cons rest))
	   (setq plist (plist-put plist :condition (pop rest))))
	 (setq plist (plist-put plist :replacement (pop rest))))
	 (when (car rest)
	   (setq plist (plist-put plist :attribute (pop rest))))
	 ;; (cpcase (extract-operands (plist-get plist :template))
	 ;;   (`(,hash . ,template)
	 ;;    (setq plist (plist-put plist :template template))
	 ;;    (setq plist (plist-put plist :operands hash))))
	 plist))

(defun parse-define-peephole2 (expr hash &optional tag)
  (unless tag
    (setq tag 'define_peephole2))
  (and (consp expr)
       (eq (car expr) tag)
       (let* ((rest (cdr expr))
	      plist)
	 (when (consp (car rest))
	   (setq plist (plist-put plist :pattern (pop rest))))
	 (when (stringp (car rest))
	   (setq plist (plist-put plist :condition-cons rest))
	   (setq plist (plist-put plist :condition (pop rest))))
	 (when (consp (car rest))
	   (setq plist (plist-put plist :replacement (pop rest))))
	 (when (stringp (car rest))
	   (setq plist (plist-put plist :preparation (pop rest))))
	 ;; (cpcase (extract-operands (plist-get plist :template))
	 ;;   (`(,hash . ,template)
	 ;;    (setq plist (plist-put plist :template template))
	 ;;    (setq plist (plist-put plist :operands hash))))
	 plist)))

(defun find-cc-reference (plist)
  (catch 'return
    (dolist (cons (all-conses plist))
      (pcase cons
	(`(REG_CC . ,rest) (throw 'return t))
	(`(match_scratch :CC . ,rest) (throw 'return t))
	(`(match_scratch :CCM . ,rest) (throw 'return t))
	(`("cc" "none") (throw 'return t))))))

(defun parse-define-insn-and-split (expr hash &optional tag)
  (unless tag
    (setq tag 'define_insn_and_split))
  (and (consp expr)
       (eq (car expr) tag)
       (let* ((rest (cdr expr))
	      plist)
	 (when (stringp (car rest))
	   (setq plist (plist-put plist :name (pop rest))))
	 (when (consp (car rest))
	   (setq plist (plist-put plist :template (pop rest))))
	 (when (stringp (car rest))
	   (setq plist (plist-put plist :condition-cons rest))
	   (setq plist (plist-put plist :condition (pop rest))))
	 (when (consp rest)
	   (setq plist (plist-put plist :assembler (pop rest))))
	 (when (stringp (car rest))
	   (setq plist (plist-put plist :split-condition (pop rest))))
	 (when (consp (car rest))
	   (setq plist (plist-put plist :replacement (pop rest))))
	 (when (stringp (car rest))
	   (setq plist (plist-put plist :preparation (pop rest))))
	 (when (consp rest)
	   (setq plist (plist-put plist :attribute (pop rest))))
	 ;; (cpcase (extract-operands (plist-get plist :template))
	 ;;   (`(,hash . ,template)
	 ;;    (setq plist (plist-put plist :template template))
	 ;;    (setq plist (plist-put plist :operands hash))))
	 (if (find-cc-reference plist)
	     nil
	   plist))))

(defun parse-define-insn (expr hash &optional tag restrict)
  (unless tag
    (setq tag 'define_insn))
  (and (consp expr)
       (eq (car expr) tag)
       (let* ((rest (cdr expr))
	      plist)
	 (when (stringp (car rest))
	   (setq plist (plist-put plist :name (pop rest))))
	 (when (consp (car rest))
	   (setq plist (plist-put plist :template (pop rest))))
	 (when (stringp (car rest))
	   (setq plist (plist-put plist :condition-cons rest))
	   (setq plist (plist-put plist :condition (pop rest))))
	 (when (consp rest)
	   (setq plist (plist-put plist :assembler (pop rest))))
	 (when (consp rest)
	   (setq plist (plist-put plist :attribute (pop rest))))
	 ;; (pcase (extract-operands (plist-get plist :template))
	 ;;   (`(,hash . ,template)
	 ;;    (setq plist (plist-put plist :template template))
	 ;;    (setq plist (plist-put plist :operands hash))))
	 (if (and restrict
		  (find-cc-reference plist))
	     nil
	   plist))))

(defun max-operand (expr)
  (cond
   ((pcase expr
      (`(match_dup ,n . ,rest) n)
      (`(,(or 'match_scratch 'match_operand) ,keyword ,n . ,rest) (if (keywordp keyword) n keyword))))
   ((consp expr)
    (max (max-operand (car expr))
	 (max-operand (cdr expr))))
   (0)))

(defun clobberify-cc-attr (ccattr n &optional force)
  (when ccattr
    (let ((attrs (split-string ccattr ",")))
      (if (or (equal attrs '("none"))
	      (equal attrs '("compare")))
	  nil
	(cond ((= (length attrs) 1)
	       `(clobber (reg :CC REG_CC)))
	      (force
	       `(clobber (match_dup ,n)))
	      (`(clobber (match_scratch :CC
			  ,n ,(concat "="
				      (mapconcat (lambda (str)
						   (if (equal str "none")
						       "X"
						     "c"))
						 attrs
						 ","))))))))))
(defun filter-cc-attr (ccattr)
  (let ((attrs (split-string ccattr)))
    (mapcar (lambda (attr) (and (member attr
					'("set_czn" "set_zn" "set_vzn"))
				t)))))

(defun resultify-cc-attr (ccattr operation)
  (cond ((not ccattr) nil)
	((equal ccattr "clobber") nil)
	(`(set (reg:CCNZ REG_CC)
	       (compare:CCNZ ,operation (const_int 0))))))

(defun find-last-real-insn (parallel)
  (catch 'return
    (setq parallel (cdr parallel))
    (let ((last (car parallel)))
      (while (consp (cdr parallel))
	(pcase (car parallel)
	  (`(clobber . ,rest) (throw 'return last))
	  (`,rest (setq last rest) (setq parallel (cdr parallel)))))
      (throw 'return last))))

(defun add-clobbers (clobbered-insns)
  (goto-char (point-min))
  (let* ((hash (make-hash-table))
	 (forms (myread hash)))
    (dolist (form forms)
      (let* ((plist (parse-define-insn form hash nil t))
	     (ccattr (find-attr (plist-get plist :attribute) "cc"))
	     (templ (plist-get plist :template))
	     (n (1+ (max-operand templ)))
	     (clobber (clobberify-cc-attr ccattr n)))
	(when clobber
	  (let* ((vector1 (cadr templ))
		 (parallel (cadr vector1))
		 (insn (find-last-real-insn parallel))
		 (ps (gethash insn hash))
		 (p0 (car ps))
		 (p1 (cdr ps))
		 (ind (save-excursion
			(goto-char p0)
			(- (current-column)
			   (length "(vector (parallel (vector")))))
	    (goto-char p1)
	    (insert "\n")
	    (setq ind (max ind 0))
	    (insert (make-string ind ?\ ))
	    (insert (format "%S" clobber)))
	  (goto-char (car (gethash form hash)))
	  (forward-char 14)
	  (cond
	   ((looking-at-p "call_insn")
	    (insert "cc_"))
	   ((looking-at-p "call_value_insn")
	    (insert "cc_"))
	   ((looking-at-p "\\*"))
	   ((insert "*")))
	  (puthash templ t clobbered-insns))))))

(defun add-results ()
  (goto-char (point-min))
  (let* ((hash (make-hash-table))
	 (forms (myread hash)))
    (dolist (form forms)
      (let* ((plist (parse-define-insn form hash nil t))
	     (ccattr (find-attr (plist-get plist :attribute) "cc"))
	     (templ (plist-get plist :template))
	     (alts (and ccattr (split-string ccattr ",")))
	     (filter (cc-alts-filter alts))
	     (operation (caddr (cadr (cadr (cadr templ)))))
	     (result (and ccattr (resultify-cc-attr ccattr operation))))
	(when (and (memq t filter)
		   result)
	  (let* ((oldstr (buffer-substring-no-properties
			  (car (gethash form hash))
			  (cdr (gethash form hash))))
		 (vector1 (cadr templ))
		 (parallel (cadr vector1))
		 (insn (find-last-real-insn parallel))
		 (ps (gethash insn hash))
		 (p0 (car ps))
		 (p1 (cdr ps))
		 (ind (save-excursion
			(goto-char p0)
			(- (current-column)
			   (length "(vector (parallel (vector")))))
	    (goto-char p0)
	    (sit-for 0)
	    (insert (format "%S" result))
	    (insert "\n")
	    (setq ind (max ind 0))
	    (insert (make-string ind ?\ ))
	    (goto-char (car (gethash form hash)))
	    (forward-char 14)
	    (unless (looking-at-p "\\*")
	      (insert "*"))
	    (goto-char (car (gethash form hash)))
	    (insert oldstr)
	    (when (not (equal oldstr ""))
	      (insert "\n\n"))))))))

(defun fix-results ()
  (goto-char (point-min))
  (let* ((hash (make-hash-table))
	 (forms (myread hash)))
    (dolist (form forms)
      (when (catch 'found
	      (dolist (cons (all-conses form))
		(pcase cons (`(reg:CCNZ REG_CC) (throw 'found t)))))
	(let* ((plist (parse-define-insn form hash nil nil))
	       (ccattr (find-attr (plist-get plist :attribute) "cc"))
	       (templ (plist-get plist :template))
	       (alts (and ccattr (split-string ccattr ",")))
	       (filter (cc-alts-filter alts))
	       (operation (caddr (cadr (cadr (cadr templ)))))
	       (condition-cons (plist-get plist :condition-cons)))
	  (when (memq t filter)
	    (when condition-cons
	      (let* ((oldc (car condition-cons))
		     (addc
		      "(avr_gen_cc_result (insn, operands) != NULL)")
		     (newc
		      (if (equal oldc "") addc
			(concat "(" oldc ") && " addc)))
		     (entry (gethash condition-cons hash))
		     (p0 (car entry))
		     (p1 (save-excursion
			   (goto-char p0)
			   (read (current-buffer))
			   (point-marker))))
		(goto-char p0)
		(delete-region p0 p1)
		(insert (format "%S" newc))))
	    (dolist (repl (explode-comma-strings-in-templ form))
	      (goto-char (car (gethash (car repl) hash)))
	      (let* ((p0 (point))
		     (str (read (current-buffer)))
		     (p1 (point))
		     (replacement (implode-alts
				   (cons (cadr repl)
					 (filter-alts (cddr repl) filter)))))
		(delete-region p0 p1)
		(insert (format "%S" replacement))))))))))


(defun fix-peepholes (clobbered-insns)
  (goto-char (point-min))
  (let* ((hash (make-hash-table))
	 (forms (myread hash)))
    (dolist (form forms)
      (let* ((plist (parse-define-peephole2 form hash)))
	(when plist
	  (let* ((templ (plist-get plist :template)))
	    (dolist (insn (cdr templ))
	      (when (gethash insn clobbered-insns)
		(error "peephole uses a clobbered insn")))))))))

(defun add-results-23 ()
  (goto-char (point-min))
  (while (let* ((hash (make-hash-table))
		(form (myread-single-form hash)))
	   (when form
	     (let ((str (buffer-substring (car (gethash form hash))
					  (cdr (gethash form hash)))))
	       (aset str 1 ?2)
	       (save-excursion
		 (goto-char (car (gethash form hash)))
		 (insert str)
		 (insert "\n\n"))
	       (aset str 1 ?3)
	       (save-excursion
		 (goto-char (car (gethash form hash)))
		 (insert str)
		 (insert "\n\n"))
	       t)))))

(defun explode-comma-string (str)
  (let ((alts (split-string str ",")))
    (if (= (length alts) 1)
	str
      `(alts-comma ,@(split-string str ",")))))

(defun explode-at-string (str)
  (if (string-match "^@\n" str)
      `(alts-at ,@(cdr (split-string str "\n")))))

(defun explode-constraint-string (constraint)
  (let ((prefix "")
	alts)
    (cond
     ((= (length constraint) 0))
     ((eq (aref constraint 0) ?=)
      (setq prefix "=")
      (setq constraint (substring constraint 1)))
     ((eq (aref constraint 0) ?%)
      (setq prefix "%")
      (setq constraint (substring constraint 1)))
     ((eq (aref constraint 0) ?+)
      (setq prefix "+")
      (setq constraint (substring constraint 1))))
    (setq alts (split-string constraint ","))
    (if (= (length alts) 1)
	constraint
      `(alts-constraint ,@(mapcar (lambda (str) (concat prefix str)) alts)))))

(defun explode-comma-strings-in-templ (templ)
  (let (repls)
    (dolist (cons (all-conses templ))
      (pcase cons
	(`(match_operand ,(and mode (pred keywordp))
			 ,number
			 ,predicate
			 . ,constraint)
	 (push (cons constraint
		     (explode-constraint-string (car constraint)))
	       repls))
	(`(match_operand ,number
			 ,(and predicate (pred stringp))
			 . ,constraint)
	 (push (cons constraint
		     (explode-constraint-string (car constraint)))
	       repls))
	(`(match_scratch ,(and mode (pred keywordp))
			 ,number
			 . ,constraint)
	 (push (cons constraint
		     (explode-constraint-string (car constraint)))
	       repls))
	(`(,(and (pred stringp) (pred (string-match "^@\n"))) . ,rest)
	 (push (cons cons
		     (explode-at-string (car cons)))
	       repls))
	(`(set_attr ,name . ,constraint)
	 (push (cons constraint
		     (explode-constraint-string (car constraint)))
	       repls))))
    (setq repls (seq-filter (lambda (c) (not (stringp (cdr c))))
			    repls))
    (nreverse repls)))

(defun implode-alts (alts)
  (pcase alts
    (`(alts-constraint . ,alts)
     (implode-to-constraint-string alts))
    (`(alts-at . ,alts)
     (implode-to-at-string alts))
    (alts alts)))

(defun implode-to-at-string (alts)
  (concat "@\n"
	  (mapconcat #'identity alts "\n")))

(defun implode-to-comma-string (alts)
  (mapconcat #'identity alts ","))

(defun implode-to-constraint-string (alts)
  (if alts
      (let ((prefix ""))
	(cond ((eq (aref (car alts) 0) ?=)
	       (setq prefix "="))
	      ((eq (aref (car alts) 0) ?%)
	       (setq prefix "%"))
	      ((eq (aref (car alts) 0) ?+)
	       (setq prefix "+")))
	(concat prefix
		(mapconcat (lambda (str) (substring str (length prefix)))
			   alts ",")))))

(defun filter-alts (alts bools)
  (let (newalts)
    (dolist (alt alts)
      (when (car bools)
	(push alt newalts))
      (setq bools (cdr bools)))
    (nreverse newalts)))

(defun cc-alts-filter (alts)
  (let (filter)
    (dolist (alt alts)
      (push t filter))
    ;(push (not (null (member alt '("set_vzn" "set_zn" "set_czn"))))
    ; filter))
    (nreverse filter)))

(defun fix-splitter ()
  (let* ((hash (make-hash-table))
	 (form (myread-single-form hash))
	 (plist (parse-define-insn-and-split form hash))
	 (new-insn-pattern (plist-get plist :replacement))
	 (nps (gethash new-insn-pattern hash))
	 (np0 (car nps))
	 (np1 (cdr nps))
	 (attributes (plist-get plist :attribute))
	 (ccattr (find-attr attributes "cc"))
	 (alts (and ccattr (split-string ccattr ",")))
	 (filter (cc-alts-filter alts))
	 (templ (plist-get plist :template))
	 (n (1+ (max-operand templ)))
	 (clobber (clobberify-cc-attr ccattr n t)))
    (if (not clobber)
	nil
      (let* ((vector1 (cadr new-insn-pattern))
	     (parallel (cadr vector1))
	     (insn (find-last-real-insn parallel))
	     (ps (gethash insn hash))
	     (p0 (car ps))
	     (p1 (cdr ps))
	     (ind (save-excursion
		    (goto-char p0)
		    (- (current-column)
		       (length "(vector (parallel (vector")))))
	(goto-char p1)
	(sit-for 0)
	(insert "\n")
	(setq ind (max ind 0))
	(insert (make-string ind ?\ ))
	(insert (format "%S" clobber))
	t))))

(defun add-splitters ()
  (goto-char (point-min))
  (let* ((hash (make-hash-table))
	 (forms (myread hash)))
    (dolist (form forms)
      (let* ((plist (parse-define-insn form hash nil t))
	     (attrs (plist-get plist :attribute))
	     (ccattr (find-attr (plist-get plist :attribute) "cc"))
	     (templ (plist-get plist :template))
	     (n (1+ (max-operand templ)))
	     (clobber (clobberify-cc-attr ccattr n t))
	     (ps (gethash form hash))
	     (p0 (car ps))
	     (p9 (copy-marker (1- p0)))
	     (tps (gethash templ hash))
	     (tp0 (car tps))
	     (tp1 (cdr tps))
	     (aps (gethash attrs hash))
	     (ap0 (car aps))
	     (ap1 (cdr aps)))
	(when templ
	  (goto-char p0)
	  (sit-for 0)
	  (insert (format "(define_insn_and_split %S\n"
			  (plist-get plist :name)))
	  (insert (format "  %s\n"
			  (buffer-substring-no-properties tp0 tp1)))
	  (insert (format "  %S\n" (plist-get plist :condition)))
	  (insert (format "  %S\n" "#"))
	  (insert (format "  %S\n" "reload_completed"))
	  (insert (format "  %s\n"
			  (buffer-substring-no-properties tp0 tp1)))
	  (pcase clobber
	    (`(clobber (match_dup . ,rest1) . ,rest2)
	     (insert (format "  \"operands[%s] = avr_gen_cc_clobber (curr_insn);\"" n)))
	    (_
	     (insert (format "  \"\"" n))))
	  (when attrs
	    (insert (format "\n  %s" (buffer-substring-no-properties ap0 ap1))))
	  (insert ")\n\n")
	  (goto-char (1+ p9))
	  (unless (fix-splitter)
	    (delete-region (point) p0)))))))

(defun all-conses (expr)
  (if (consp expr)
      (append (list expr)
	      (all-conses (car expr))
	      (all-conses (cdr expr)))
    nil))

(defun dupify-insns ()
  (goto-char (point-min))
  (let* ((hash (make-hash-table))
	 (forms (myread hash)))
    (dolist (form forms)
      (let ((hash2 (make-hash-table :test 'equal)))
	(dolist (cons (all-conses form))
	  (pcase cons
	    (`(,(or 'match_operand 'match_scratch) ,mode ,n . ,rest)
	     (if (gethash cons hash2)
		 (progn
		   (goto-char (car (gethash cons hash)))
		   (delete-region (point)
				  (cdr (gethash cons hash)))
		   (insert (format "%S"
				   (if (numberp mode)
				       `(match_dup ,mode)
				     `(match_dup ,n)))))
	       (puthash cons t hash2)))))))))

(defun make-all-insns-parallel ()
  (goto-char (point-min))
  (let* ((hash (make-hash-table))
	 (forms (myread hash)))
    (dolist (form forms)
      (pcase form
	(`(,(or 'define_insn 'define_insn_and_split) ,name (vector (parallel .  ,rest1) . ,rest2) . ,rest3)
	  )
	(`(,(or 'define_insn 'define_insn_and_split) ,name ,(and subform `(vector . ,rest1)) . ,rest2)
	 (let* ((ps (gethash subform hash))
		(p0 (car ps))
		(p1 (cdr ps)))
	   (goto-char (+ p0 8))
	   (insert "(parallel (vector ")
	   (goto-char p1)
	   (insert "))")))))))

(defun make-all-insns-serial ()
  (goto-char (point-min))
  (let* ((hash (make-hash-table))
	 (forms (myread hash)))
    (dolist (form forms)
      (pcase form
	(`(,(or 'define_insn 'define_insn_and_split)
	   ,name ,(and v `(vector (parallel . ,rest1))) . ,rest2)
	 (let* ((ps (gethash v hash))
		(p0 (car ps))
		(p1 (cdr ps)))
	   (goto-char (1- p0))
	   (delete-char (length "(vector (parallel "))
 	   (goto-char (- p1 2))
	   (delete-char 2)))))))

(defun convert-rtl-buffer ()
  (let ((clobbered-insns (make-hash-table :test 'equal)))
    (make-all-insns-parallel)
    (add-splitters)
    (add-results)
    (add-clobbers clobbered-insns)
    (fix-peepholes clobbered-insns)
    (fix-results)
    (dupify-insns)
    (make-all-insns-serial)))

(defun gnurlify (filename)
  (interactive "f")
  (with-temp-buffer
    (display-buffer (current-buffer))
    (insert-file-contents filename)
    (goto-char (point-min))
    (elispify-rtl)
    (goto-char (point-min))
    (elispify-pass-2)
    (goto-char (point-min))
    (mangle-rtl-buffer)
    (convert-rtl-buffer)
    (goto-char (point-min))
    (gnurl-to-rtl)
    (write-file (concat filename ".new"))))

(defun gnurl-to-rtl-braced-string ()
  (let* ((p0 (point))
	 (str (read (current-buffer)))
	 (p1 (point-marker)))
    (goto-char p1)
    (while (not (looking-back "\""))
      (forward-char -1))
    (setq p1 (point-marker))
    (goto-char p0)
    (delete-char 1)
    (while (< (point) p1)
      (cond ((looking-at-p "\\\\")
	     (delete-char 1)
	     (forward-char))
	    ((looking-at-p "\\\\\"")
	     (delete-char 1)
	     (forward-char))
	    ((forward-char))))
    (goto-char (1- p1))
    (delete-char 1)))

(defun gnurl-to-rtl-string ()
  (let* ((p0 (point))
	 (str (read (current-buffer)))
	 (p1 (point-marker)))
    (goto-char p0)
    (while (< (point) p1)
      (cond ((looking-at-p "\\\\")
	     (delete-char 1)
	     (forward-char))
	    ((forward-char))))))

(defun gnurl-to-rtl ()
  (interactive)
  (gnurl-to-elispified-rtl)
  (indent-elispified-rtl)
  (elispified-rtl-to-rtl))

(defun gnurl-to-elispified-rtl ()
  (interactive)
  (let ((hash (make-hash-table))
	conses)
    (myread hash)
    (maphash (lambda (key val)
	       (push key conses))
	     hash)
    (dolist (form conses)
      (when (eq (car-safe form) 'vector)
	(save-excursion
	  (goto-char (car (gethash form hash)))
	  (delete-region (point)
			 (+ (point) (length "(vector ")))
	  (insert "["))
	(save-excursion
	  (goto-char (1- (cdr (gethash form hash))))
	  (delete-region (point) (1+ (point)))
	  (insert "]")))))
  (goto-char (point-min))
  (while (not (eobp))
    (cond ((looking-at-p ";")
	   (myread-skip-comment))
	  ((looking-at-p "[ \t\n]")
	   (myread-skip-whitespace))
	  ((looking-at-p "[][()]")
	   (forward-char))
	  ((looking-at-p ":")
	   (while (looking-back " ")
	     (forward-char -1)
	     (delete-char 1))
	   (forward-char))
	  ((let ((p (point))
		 (sym (read (current-buffer)))))))))

(defun indent-elispified-rtl ()
  (let ((str (buffer-string)))
    (with-temp-buffer
      (insert str)
      (emacs-lisp-mode)
      (put-text-property (point-min) (point-max)
			 'lisp-indent-function 0)
      (indent-region (point-min) (point-max))
      (setq str (buffer-string)))
    (erase-buffer)
    (insert str)))

(defun elispified-rtl-to-rtl ()
  (interactive)
  (let ((hash (make-hash-table))
	conses)
    (myread hash)
    (maphash (lambda (key val)
	       (push key conses))
	     hash)
    (dolist (form conses)
      (when (eq (car-safe form) 'vector)
	(save-excursion
	  (goto-char (car (gethash form hash)))
	  (delete-region (point)
			 (+ (point) (length "(vector ")))
	  (insert "["))
	(save-excursion
	  (goto-char (1- (cdr (gethash form hash))))
	  (delete-region (point) (1+ (point)))
	  (insert "]")))))
  (goto-char (point-min))
  (while (not (eobp))
    (cond ((looking-at-p ";")
	   (myread-skip-comment))
	  ((looking-at-p "[ \t\n]")
	   (myread-skip-whitespace))
	  ((looking-at-p "[][()]")
	   (forward-char))
	  ((looking-at-p ":")
	   (while (looking-back " ")
	     (forward-char -1)
	     (delete-char 1))
	   (forward-char))
	  ((looking-at-p "\"{")
	   (gnurl-to-rtl-braced-string))
	  ((looking-at-p "\"")
	   (gnurl-to-rtl-string))
	  ((let ((p (point))
		 (sym (read (current-buffer)))))))))

(defun myread-skip-comment ()
  (while (not (eolp))
    (forward-char 1)))

(defun myread-skip-whitespace ()
  (while (looking-at-p "[ \n\t]")
    (forward-char 1)))

(defun myread (hash)
  (let ((stack (list nil))
	(p0stack (list (point-marker))))
    (while (not (eobp))
      (cond
       ((looking-at-p ";")
	(myread-skip-comment))
       ((looking-at-p "[ \t\n]")
	(myread-skip-whitespace))
       ((looking-at-p "(")
	(push nil stack)
	(push (point-marker) p0stack)
	(forward-char))
       ((looking-at-p "\"")
	(let* ((p0 (point-marker))
	       (val (read (current-buffer)))
	       (p1 (point-marker)))
	  (push (cons (cons p0 p1) val) (car stack))))
       ((looking-at-p ")")
	(forward-char)
	(let ((p0 (pop p0stack))
	      (p1 (point-marker)))
	  (let* ((list (pop stack))
		 vlist)
	    (dolist (l list)
	      (push (cdr l) vlist)
	      (puthash vlist (cons (caar l) p1) hash)
	      )
	    (puthash vlist (cons p0 p1) hash)
	    (push (cons (cons p0 p1)
			vlist)
		  (car stack)))))
       ((let* ((p0 (point-marker))
	       (val (read (current-buffer)))
	       (p1 (point-marker)))
	  (push (cons (cons p0 p1) val) (car stack))))))
    (let* ((list (pop stack))
	   vlist)
      (dolist (l list)
	(push (cdr l) vlist)
	;;(puthash vlist (cons (caar l) (point-marker)) hash)
	)
      (puthash vlist (cons (pop p0stack) (point-marker)) hash)
      vlist)))

(defun myread-single-form (hash)
  (catch 'return
    (let ((stack (list nil))
	  (p0stack (list (point-marker))))
      (while (not (eobp))
	(cond
	 ((looking-at-p ";")
	  (myread-skip-comment))
	 ((looking-at-p "[ \t\n]")
	  (myread-skip-whitespace))
	 ((looking-at-p "(")
	  (push nil stack)
	  (push (point-marker) p0stack)
	  (forward-char))
	 ((looking-at-p "\"")
	  (push (read (current-buffer)) (car stack)))
	 ((looking-at-p ")")
	  (forward-char)
	  (let ((list (pop stack)))
	    (push (nreverse list) (car stack)))
	  (puthash (caar stack) (cons (pop p0stack) (point-marker)) hash)
	  (if (= (length stack) 1)
	      (throw 'return (caar stack))))
	 ((push (read (current-buffer)) (car stack))))))))

(defun elispify-braced-string ()
  (let ((brace-level 1))
    (insert "\"")
    (forward-char)
    (catch 'return
      (while (not (eobp))
	(cond
	 ((looking-at-p "{")
	  (forward-char)
	  (incf brace-level))
	 ((looking-at-p "}")
	  (forward-char)
	  (decf brace-level)
	  (if (= brace-level 0)
	      (throw 'return nil)))
	 ((looking-at-p "\"")
	  (insert "\\")
	  (forward-char))
	 ((looking-at-p "\\\\")
	  (insert "\\")
	  (forward-char))
	 ((forward-char)))))
    (insert "\"")))

(defun elispify-string ()
  (forward-char)
  (catch 'return
    (while (not (eobp))
      (cond
       ((looking-at-p "\"")
	(forward-char)
	(throw 'return nil))
       ((looking-at-p "\\\\")
	(insert "\\")
	(forward-char)
	(forward-char))
       ((forward-char))))))

(defun elispify-comment ()
  (while (not (eolp))
    (forward-char)))

(defun elispify-rtl ()
  (while (not (eobp))
    (cond
     ((looking-at-p "{")
      (elispify-braced-string))
     ((looking-at-p "\"")
      (elispify-string))
     ((looking-at-p ";")
      (elispify-comment))
     ((forward-char)))))

(defun ep2-skip-comment ()
  (while (not (eolp))
    (forward-char 1)))

(defun ep2-skip-whitespace ()
  (while (looking-at-p "[ \n\t]")
    (forward-char 1)))

(defun ep2-string ()
  (let ((string (read (current-buffer))))))

(defun ep2-symbol-or-number ()
  (let* ((p (point))
	 (symnum (read (current-buffer))))
    (and (symbolp symnum)
	 (string-match ":" (symbol-name symnum))
	 (let ((p2 (point-marker)))
	   (goto-char p)
	   (while (search-forward ":" p2 t)
	     (forward-char -1)
	     (insert " ")
	     (forward-char))
	   (goto-char p2)))))

(defun elispify-pass-2 ()
  (let (stack)
    (while (not (eobp))
      (cond
       ((looking-at-p ";")
	(ep2-skip-comment))
       ((looking-at-p "[ \n\t]")
	(ep2-skip-whitespace))
       ((looking-at-p "(")
	(push (cons "(" (point)) stack)
	(forward-char))
       ((looking-at-p "\\[")
	(push (cons "[" (point)) stack)
	(delete-char 1)
	(insert "(vector "))
       ((looking-at-p ")")
	(assert (equal (car (pop stack)) "("))
	(forward-char))
       ((looking-at-p "]")
	(assert (equal (car (pop stack)) "["))
	(delete-char 1)
	(insert ")"))
       ((looking-at-p "\"")
	(ep2-string))
       ((ep2-symbol-or-number))))))

(defmacro ploop (expr &rest cases)
  (declare (indent 1) (debug (form &rest (pcase-PAT body))))
  `(catch 'ploop
     (let ((x ,expr))
       (while t
	 (setq x (pcase x ,@cases (_ (throw 'ploop x))))))))

(defun find-cc-clobber (template)
  (catch 'return
    (ploop (cdr template)
      (`((clobber (reg:CC REG_CC)) . ,rest) (throw 'return t))
      (`(,dummy . ,rest) rest))))

(defun find-cc-attr (attribute)
  (catch 'return
    (ploop (cdr attribute)
      (`((set_attr "cc" "none") . ,rest) rest)
      (`((set_attr "cc" ,any) . ,rest) (throw 'return t))
      (`(,any . ,rest) rest))))

(defun find-attr (attribute name)
  (catch 'return
    (ploop (cdr attribute)
      (`((set_attr ,name2 ,any) . ,rest) (if (equal name name2) (throw 'return any) rest))
      (`(,any . ,rest) rest))))

(defun check-define-insn (rest point)
  (let (plist)
    (when (stringp (car rest))
      (setq plist (plist-put plist :name (pop rest))))
    (when (consp (car rest))
      (setq plist (plist-put plist :template (pop rest))))
    (when (stringp (car rest))
      (setq plist (plist-put plist :condition (pop rest))))
    (when (consp rest)
      (setq plist (plist-put plist :assembler (pop rest))))
    (when (consp rest)
      (setq plist (plist-put plist :attribute (pop rest))))
    ;; (pcase (extract-operands (plist-get plist :template))
    ;;   (`(,hash . ,template)
    ;;    (setq plist (plist-put plist :template template))
    ;;    (setq plist (plist-put plist :operands hash))))
    (let ((print-circle t))
      (when (and (find-cc-clobber (plist-get plist :template))
		 (not (find-cc-attr (plist-get plist :attribute))))
	(save-excursion
	  (goto-char point)
	  (insert ";; unnecessary clobber"))))))

(defun mangle-define-insn (rest hash)
  (let (plist)
    (when (stringp (car rest))
      (setq plist (plist-put plist :name (pop rest))))
    (when (consp (car rest))
      (setq plist (plist-put plist :template (pop rest))))
    (when (stringp (car rest))
      (setq plist (plist-put plist :condition (pop rest))))
    (when (consp rest)
      (setq plist (plist-put plist :assembler (pop rest))))
    (when (consp rest)
      (setq plist (plist-put plist :attribute (pop rest))))
    ;; (pcase (extract-operands (plist-get plist :template))
    ;;   (`(,hash . ,template)
    ;;    (setq plist (plist-put plist :template template))
    ;;    (setq plist (plist-put plist :operands hash))))
    (let ((print-circle t))
      (unless (find-attr (plist-get plist :attribute) "cc")
	(insert ";; no clobber\n")))))

(defun read-rtl-file (file)
  (interactive "f")
  (with-temp-buffer
    (display-buffer (current-buffer))
    (insert-file-contents file)
    (goto-char (point-min))
    (elispify-rtl)
    (goto-char (point-min))
    (elispify-pass-2)
    (goto-char (point-min))
    (let* ((hash (make-hash-table))
	   (forms (myread hash)))
      (dolist (form forms)
	(let ((p0 (car (gethash form hash)))
	      (p1 (cdr (gethash form hash))))
	  (goto-char p0)
	  (sit-for 0)
	  (pcase form
	    (`(define_insn . ,rest)
	      (mangle-define-insn rest hash))))))
    (condition-case error
	(while (not (eobp))
	  (let* ((opoint (point-marker))
		 (form (read (current-buffer)))
		 (npoint (point-marker)))
	    ;;(delete-region opoint npoint)
	    ;;(setq form (mangle-rtl form))
	    (sit-for 0)
	    ;;(let ((res (interpret-rtl form)))
	    ;;  (when res
	    ;;    (setq form res)))
	    ;;(insert (pp form))
	    (pcase form
	      (`(define_insn . ,rest)
	       (check-define-insn rest opoint)))
	    (pcase form
	      (`(define_insn ,name (vector (parallel (vector . ,rest)) . ,rest3) . ,rest2)
	       (warn "parallel in a define_insn %S" (point))))))
      (error nil))
    (write-file "~/tmp.gnurl")))

(defun mangle-rtl-buffer ()
  (display-buffer (current-buffer))
  (goto-char (point-min))
  ;;(elispify-rtl)
  (goto-char (point-min))
  ;;(elispify-pass-2)
  (goto-char (point-min))
  (let* ((hash (make-hash-table))
	 (forms (myread hash)))
    (dolist (form forms)
      (when (consp form)
	(let ((p0 (car (gethash form hash)))
	      (p1 (cdr (gethash form hash))))
	  (goto-char p0)
	  (sit-for 0)
	  (pcase form
	    (`(define_insn . ,rest)
	     (mangle-define-insn rest hash)))))))
  (condition-case error
      (while (not (eobp))
	(let* ((opoint (point-marker))
	       (form (read (current-buffer)))
	       (npoint (point-marker)))
	  ;;(delete-region opoint npoint)
	  ;;(setq form (mangle-rtl form))
	  (sit-for 0)
	  ;;(let ((res (interpret-rtl form)))
	  ;;  (when res
	  ;;    (setq form res)))
	  ;;(insert (pp form))
	  (pcase form
	    (`(define_insn . ,rest)
	     (check-define-insn rest opoint)))
	  (pcase form
	    (`(define_insn ,name (vector (parallel (vector . ,rest)) . ,rest3) . ,rest2)
	     (warn "parallel in a define_insn %S" (point))))))
    (error nil)))
