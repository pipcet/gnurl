;; -*- lexical-binding: t -*-

(defun myread-skip-comment ()
  (while (not (eolp))
    (forward-char 1)))

(defun myread-skip-whitespace ()
  (while (looking-at-p "[ \n\t]")
    (forward-char 1)))

(defun myread (hash)
  (let ((stack (list nil))
	(p0stack (list (point-marker))))
    (while (not (eobp))
      (cond
       ((looking-at-p ";")
	(myread-skip-comment))
       ((looking-at-p "[ \t\n]")
	(myread-skip-whitespace))
       ((looking-at-p "(")
	(push nil stack)
	(push (point-marker) p0stack)
	(forward-char))
       ((looking-at-p "\"")
	(push (read (current-buffer)) (car stack)))
       ((looking-at-p ")")
	(forward-char)
	(let ((list (pop stack)))
	  (push (nreverse list) (car stack))
	  (puthash (caar stack) (cons (pop p0stack) (point-marker)) hash)))
       ((push (read (current-buffer)) (car stack)))))
    (nreverse (car stack))))

(defun myread-single-form (hash)
  (catch 'return
    (let ((stack (list nil))
	  (p0stack (list (point-marker))))
      (while (not (eobp))
	(cond
	 ((looking-at-p ";")
	  (myread-skip-comment))
	 ((looking-at-p "[ \t\n]")
	  (myread-skip-whitespace))
	 ((looking-at-p "(")
	  (push nil stack)
	  (push (point-marker) p0stack)
	  (forward-char))
	 ((looking-at-p "\"")
	  (push (read (current-buffer)) (car stack)))
	 ((looking-at-p ")")
	  (forward-char)
	  (let ((list (pop stack)))
	    (push (nreverse list) (car stack)))
	  (while (= (length stack) 1)
	    (cond ((eobp) (puthash (caar stack) (cons (pop p0stack) (point-marker)) hash) (throw 'return (caar stack)))
		  ((looking-at-p ";") (myread-skip-comment))
		  ((looking-at-p "[ \t\n]") (myread-skip-whitespace))
		  ((puthash (caar stack) (cons (pop p0stack) (point-marker)) hash)
		   (throw 'return (caar stack)))))
	  (puthash (caar stack) (cons (pop p0stack) (point-marker)) hash))
	 ((push (read (current-buffer)) (car stack))))))))

(defun elispify-braced-string ()
  (let ((brace-level 1))
    (insert "\"")
    (forward-char)
    (catch 'return
      (while (not (eobp))
	(cond
	 ((looking-at-p "{")
	  (forward-char)
	  (incf brace-level))
	 ((looking-at-p "}")
	  (forward-char)
	  (decf brace-level)
	  (if (= brace-level 0)
	      (throw 'return nil)))
	 ((looking-at-p "\"")
	  (insert "\\")
	  (forward-char))
	 ((looking-at-p "\\\\")
	  (insert "\\")
	  (forward-char))
	 ((forward-char)))))
    (insert "\"")))

(defun elispify-string ()
  (forward-char)
  (catch 'return
    (while (not (eobp))
      (cond
       ((looking-at-p "\"")
	(forward-char)
	(throw 'return nil))
       ((looking-at-p "\\\\")
	(insert "\\")
	(forward-char)
	(forward-char))
       ((forward-char))))))

(defun elispify-comment ()
  (while (not (eolp))
    (forward-char)))

(defun elispify-rtl ()
  (while (not (eobp))
    (cond
     ((looking-at-p "{")
      (elispify-braced-string))
     ((looking-at-p "\"")
      (elispify-string))
     ((looking-at-p ";")
      (elispify-comment))
     ((forward-char)))))

(defun ep2-skip-comment ()
  (while (not (eolp))
    (forward-char 1)))

(defun ep2-skip-whitespace ()
  (while (looking-at-p "[ \n\t]")
    (forward-char 1)))

(defun ep2-string ()
  (let ((string (read (current-buffer))))))

(defun ep2-symbol-or-number ()
  (let* ((p (point))
	 (symnum (read (current-buffer))))
    (and (symbolp symnum)
	 (string-match ":" (symbol-name symnum))
	 (let ((p2 (point-marker)))
	   (goto-char p)
	   (while (search-forward ":" p2 t)
	     (forward-char -1)
	     (insert " ")
	     (forward-char))
	   (goto-char p2)))))

(defun elispify-pass-2 ()
  (let (stack)
    (while (not (eobp))
      (cond
       ((looking-at-p ";")
	(ep2-skip-comment))
       ((looking-at-p "[ \n\t]")
	(ep2-skip-whitespace))
       ((looking-at-p "(")
	(push (cons "(" (point)) stack)
	(forward-char))
       ((looking-at-p "\\[")
	(push (cons "[" (point)) stack)
	(delete-char 1)
	(insert "(vector "))
       ((looking-at-p ")")
	(assert (equal (car (pop stack)) "("))
	(forward-char))
       ((looking-at-p "]")
	(assert (equal (car (pop stack)) "["))
	(delete-char 1)
	(insert ")"))
       ((looking-at-p "\"")
	(ep2-string))
       ((ep2-symbol-or-number))))))

(defmacro ploop (expr &rest cases)
  (declare (indent 1) (debug (form &rest (pcase-PAT body))))
  `(catch 'ploop
     (let ((x ,expr))
       (while t
	 (setq x (pcase x ,@cases (_ (throw 'ploop x))))))))

(defun find-cc-clobber (template)
  (catch 'return
    (ploop (cdr template)
      (`((clobber (reg:CC REG_CC)) . ,rest) (throw 'return t))
      (`(,dummy . ,rest) rest))))

(defun find-cc-attr (attribute)
  (catch 'return
    (ploop (cdr attribute)
      (`((set_attr "cc" "none") . ,rest) rest)
      (`((set_attr "cc" ,any) . ,rest) (throw 'return t))
      (`(,any . ,rest) rest))))

(defun find-attr (attribute name)
  (catch 'return
    (ploop (cdr attribute)
      (`((set_attr ,name2 ,any) . ,rest) (if (equal name name2) (throw 'return any) rest))
      (`(,any . ,rest) rest))))

(defun check-define-insn (rest point)
  (let (plist)
    (when (stringp (car rest))
      (setq plist (plist-put plist :name (pop rest))))
    (when (consp (car rest))
      (setq plist (plist-put plist :template (pop rest))))
    (when (stringp (car rest))
      (setq plist (plist-put plist :condition (pop rest))))
    (when (consp rest)
      (setq plist (plist-put plist :assembler (pop rest))))
    (when (consp rest)
      (setq plist (plist-put plist :attribute (pop rest))))
    ;; (pcase (extract-operands (plist-get plist :template))
    ;;   (`(,hash . ,template)
    ;;    (setq plist (plist-put plist :template template))
    ;;    (setq plist (plist-put plist :operands hash))))
    (let ((print-circle t))
      (when (and (find-cc-clobber (plist-get plist :template))
		 (not (find-cc-attr (plist-get plist :attribute))))
	(save-excursion
	  (goto-char point)
	  (insert ";; unnecessary clobber"))))))

(defun mangle-define-insn (rest hash)
  (let (plist)
    (when (stringp (car rest))
      (setq plist (plist-put plist :name (pop rest))))
    (when (consp (car rest))
      (setq plist (plist-put plist :template (pop rest))))
    (when (stringp (car rest))
      (setq plist (plist-put plist :condition (pop rest))))
    (when (consp rest)
      (setq plist (plist-put plist :assembler (pop rest))))
    (when (consp rest)
      (setq plist (plist-put plist :attribute (pop rest))))
    ;; (pcase (extract-operands (plist-get plist :template))
    ;;   (`(,hash . ,template)
    ;;    (setq plist (plist-put plist :template template))
    ;;    (setq plist (plist-put plist :operands hash))))
    (let ((print-circle t))
      (unless (find-attr (plist-get plist :attribute) "cc")
	(insert ";; no clobber\n")))))

(defun read-rtl-file (file)
  (interactive "f")
  (with-temp-buffer
    (display-buffer (current-buffer))
    (insert-file-contents file)
    (goto-char (point-min))
    (elispify-rtl)
    (goto-char (point-min))
    (elispify-pass-2)
    (goto-char (point-min))
    (let* ((hash (make-hash-table))
	   (forms (myread hash)))
      (dolist (form forms)
	(let ((p0 (car (gethash form hash)))
	      (p1 (cdr (gethash form hash))))
	  (goto-char p0)
	  (sit-for 0)
	  (pcase form
	    (`(define_insn . ,rest)
	      (mangle-define-insn rest hash))))))
    (condition-case error
	(while (not (eobp))
	  (let* ((opoint (point-marker))
		 (form (read (current-buffer)))
		 (npoint (point-marker)))
	    ;;(delete-region opoint npoint)
	    ;;(setq form (mangle-rtl form))
	    (sit-for 0)
	    ;;(let ((res (interpret-rtl form)))
	    ;;  (when res
	    ;;    (setq form res)))
	    ;;(insert (pp form))
	    (pcase form
	      (`(define_insn . ,rest)
	       (check-define-insn rest opoint)))
	    (pcase form
	      (`(define_insn ,name (vector (parallel (vector . ,rest)) . ,rest3) . ,rest2)
	       (warn "parallel in a define_insn %S" (point))))))
      (error nil))
    (write-file "~/tmp.gnurl")))

(defun mangle-rtl-buffer ()
  (display-buffer (current-buffer))
  (goto-char (point-min))
  ;;(elispify-rtl)
  (goto-char (point-min))
  ;;(elispify-pass-2)
  (goto-char (point-min))
  (let* ((hash (make-hash-table))
	 (forms (myread hash)))
    (dolist (form forms)
      (when (consp form)
	(let ((p0 (car (gethash form hash)))
	      (p1 (cdr (gethash form hash))))
	  (goto-char p0)
	  (sit-for 0.1)
	  (pcase form
	    (`(define_insn . ,rest)
	     (mangle-define-insn rest hash)))))))
  (condition-case error
      (while (not (eobp))
	(let* ((opoint (point-marker))
	       (form (read (current-buffer)))
	       (npoint (point-marker)))
	  ;;(delete-region opoint npoint)
	  ;;(setq form (mangle-rtl form))
	  (sit-for 0)
	  ;;(let ((res (interpret-rtl form)))
	  ;;  (when res
	  ;;    (setq form res)))
	  ;;(insert (pp form))
	  (pcase form
	    (`(define_insn . ,rest)
	     (check-define-insn rest opoint)))
	  (pcase form
	    (`(define_insn ,name (vector (parallel (vector . ,rest)) . ,rest3) . ,rest2)
	     (warn "parallel in a define_insn %S" (point))))))
    (error nil)))
