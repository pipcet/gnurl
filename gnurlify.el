;; -*- lexical-binding: t -*-

(defun parse-define-insn-and-split (expr hash &optional tag)
  (unless tag
    (setq tag 'define_insn_and_split))
  (and (consp expr)
       (eq (car expr) tag)
       (let* ((rest (cdr expr))
	      plist)
	 (when (stringp (car rest))
	   (setq plist (plist-put plist :name (pop rest))))
	 (when (consp (car rest))
	   (setq plist (plist-put plist :template (pop rest))))
	 (when (stringp (car rest))
	   (setq plist (plist-put plist :condition (pop rest))))
	 (when (consp rest)
	   (setq plist (plist-put plist :assembler (pop rest))))
	 (when (stringp (car rest))
	   (setq plist (plist-put plist :split-condition (pop rest))))
	 (when (consp (car rest))
	   (setq plist (plist-put plist :replacement (pop rest))))
	 (when (stringp (car rest))
	   (setq plist (plist-put plist :preparation (pop rest))))
	 (when (consp rest)
	   (setq plist (plist-put plist :attribute (pop rest))))
	 ;; (cpcase (extract-operands (plist-get plist :template))
	 ;;   (`(,hash . ,template)
	 ;;    (setq plist (plist-put plist :template template))
	 ;;    (setq plist (plist-put plist :operands hash))))
	 plist)))

(defun parse-define-insn (expr hash &optional tag)
  (unless tag
    (setq tag 'define_insn))
  (and (consp expr)
       (eq (car expr) tag)
       (let* ((rest (cdr expr))
	      plist)
	 (when (stringp (car rest))
	   (setq plist (plist-put plist :name (pop rest))))
	 (when (consp (car rest))
	   (setq plist (plist-put plist :template (pop rest))))
	 (when (stringp (car rest))
	   (setq plist (plist-put plist :condition (pop rest))))
	 (when (consp rest)
	   (setq plist (plist-put plist :assembler (pop rest))))
	 (when (consp rest)
	   (setq plist (plist-put plist :attribute (pop rest))))
	 ;; (pcase (extract-operands (plist-get plist :template))
	 ;;   (`(,hash . ,template)
	 ;;    (setq plist (plist-put plist :template template))
	 ;;    (setq plist (plist-put plist :operands hash))))
	 plist)))

(defun max-operand (expr)
  (cond
   ((consp expr)
    (max (max-operand (car expr))
	 (max-operand (cdr expr))))
   ((numberp expr)
    expr)
   (-1.0e+INF)))

(defun clobberify-cc-attr (ccattr n)
  (when ccattr
    (let ((attrs (split-string ccattr ",")))
      (if (equal attrs '("none"))
	  nil
	(if (= (length attrs) 1)
	    `(clobber:CC (reg:CC REG_CC))
	  `(clobber:CC (match_scratch:CC ,n ,(mapconcat (lambda (str)
							 (if (equal str "none")
							     "X"
							   "c"))
							attrs
							","))))))))

(defun resultify-cc-attr (ccattr operation)
  (when ccattr
    (let ((attrs (split-string ccattr ",")))
      (and (not (equal attrs '("none")))
	   (= (length attrs) 1)
	   (member (car attrs)
		   '("set_czn" "set_zn" "set_vzn" "set_n" "plus"))
	   `(set (reg:CCNZ REG_CC)
		 (compare:CCNZ ,operation (const_int 0)))))))

(defun add-clobbers (&optional tag)
  (goto-char (point-min))
  (let* ((hash (make-hash-table))
	 (forms (myread hash)))
    (dolist (form forms)
      (let* ((plist (parse-define-insn form hash tag))
	     (ccattr (find-attr (plist-get plist :attribute) "cc"))
	     (templ (plist-get plist :template))
	     (n (1+ (max-operand templ)))
	     (clobber (clobberify-cc-attr ccattr n)))
	(when clobber
	  (let* ((vector1 (cadr templ))
		 (parallel (cadr vector1))
		 (insn (cadr parallel))
		 (ps (gethash insn hash))
		 (p0 (car ps))
		 (p1 (cdr ps))
		 (ind (save-excursion
			(goto-char p0)
			(- (current-column)
			   (length "(vector (parallel (vector")))))
	    (goto-char p1)
	    (insert "\n")
	    (insert (make-string ind ?\ ))
	    (insert (format "%S" clobber)))
	  (goto-char (car (gethash form hash)))
	  (forward-char 14)
	  (unless (looking-at-p "\\*")
	    (insert "*")))))))

(defun add-results (&optional tag)
  (goto-char (point-min))
  (let* ((hash (make-hash-table))
	 (forms (myread hash)))
    (dolist (form forms)
      (let* ((plist (parse-define-insn form hash tag))
	     (ccattr (find-attr (plist-get plist :attribute) "cc"))
	     (templ (plist-get plist :template))
	     (operation (caddr (cadr (cadr (cadr templ)))))
	     (result (resultify-cc-attr ccattr operation)))
	(when result
	  (let* ((oldstr (buffer-substring-no-properties
			  (car (gethash form hash))
			  (cdr (gethash form hash))))
		 (vector1 (cadr templ))
		 (parallel (cadr vector1))
		 (insn (cadr parallel))
		 (ps (gethash insn hash))
		 (p0 (car ps))
		 (p1 (cdr ps))
		 (ind (save-excursion
			(goto-char p0)
			(- (current-column)
			   (length "(vector (parallel (vector")))))
	    (goto-char p0)
	    (insert (format "%S" result))
	    (insert "\n")
	    (insert (make-string ind ?\ ))
	    (goto-char (car (gethash form hash)))
	    (forward-char 14)
	    (unless (looking-at-p "\\*")
	      (insert "*"))
	    (goto-char (car (gethash form hash)))
	    (insert oldstr)
	    (insert "\n\n")))))))

(defun add-results-23 ()
  (goto-char (point-min))
  (while (let* ((hash (make-hash-table))
		(form (myread-single-form hash)))
	   (when form
	     (let ((str (buffer-substring (car (gethash form hash))
					  (cdr (gethash form hash)))))
	       (aset str 1 ?2)
	       (save-excursion
		 (goto-char (car (gethash form hash)))
		 (insert str)
		 (insert "\n\n"))
	       (aset str 1 ?3)
	       (save-excursion
		 (goto-char (car (gethash form hash)))
		 (insert str)
		 (insert "\n\n"))
	       t)))))

(defun fix-splitter ()
  (let* ((hash (make-hash-table))
	 (form (myread-single-form hash))
	 (plist (parse-define-insn-and-split form hash))
	 (new-insn-pattern (plist-get plist :replacement))
	 (nps (gethash new-insn-pattern hash))
	 (np0 (car nps))
	 (np1 (cdr nps))
	 (attributes (plist-get plist :attribute))
	 (ccattr (find-attr attributes "cc"))
	 (templ (plist-get plist :template))
	 (n (1+ (max-operand templ)))
	 (clobber (clobberify-cc-attr ccattr n)))
    (when clobber
      (let* ((vector1 (cadr new-insn-pattern))
	     (parallel (cadr vector1))
	     (insn (cadr parallel))
	     (ps (gethash insn hash))
	     (p0 (car ps))
	     (p1 (cdr ps))
	     (ind (save-excursion
		    (goto-char p0)
		    (- (current-column)
		       (length "(vector (parallel (vector")))))
	(goto-char p1)
	(insert "\n")
	(insert (make-string ind ?\ ))
	(insert (format "%S" clobber))))))

(defun add-splitters ()
  (goto-char (point-min))
  (let* ((hash (make-hash-table))
	 (forms (myread hash)))
    (dolist (form forms)
      (let* ((plist (parse-define-insn form hash))
	     (attrs (plist-get plist :attribute))
	     (ccattr (find-attr (plist-get plist :attribute) "cc"))
	     (templ (plist-get plist :template))
	     (ps (gethash form hash))
	     (p0 (car ps))
	     (p9 (copy-marker (1- p0)))
	     (tps (gethash templ hash))
	     (tp0 (car tps))
	     (tp1 (cdr tps))
	     (aps (gethash attrs hash))
	     (ap0 (car aps))
	     (ap1 (cdr aps)))
	(when templ
	  (goto-char p0)
	  (insert (format "(define_insn_and_split %S\n"
			  (plist-get plist :name)))
	  (insert (format "  %s\n"
			  (buffer-substring-no-properties tp0 tp1)))
	  (insert (format "  %S\n" (plist-get plist :condition)))
	  (insert (format "  %S\n" "#"))
	  (insert (format "  %S\n" "reload_completed"))
	  (insert (format "  %s\n"
			  (buffer-substring-no-properties tp0 tp1)))
	  (insert (format "  %S" ""))
	  (when attrs
	    (insert (format "\n  %s" (buffer-substring-no-properties ap0 ap1))))
	  (insert ")\n\n")
	  (goto-char (1+ p9))
	  (fix-splitter))))))

(defun all-conses (expr)
  (if (consp expr)
      (append (list expr)
	      (all-conses (car expr))
	      (all-conses (cdr expr)))
    nil))

(defun dupify-insns ()
  (goto-char (point-min))
  (let* ((hash (make-hash-table))
	 (forms (myread hash)))
    (dolist (form forms)
      (let ((hash2 (make-hash-table :test 'equal)))
	(dolist (cons (all-conses form))
	  (pcase cons
	    (`(match_operand ,mode ,n . ,rest)
	     (if (gethash cons hash2)
		 (progn
		   (goto-char (car (gethash cons hash)))
		   (delete-region (point)
				  (cdr (gethash cons hash)))
		   (insert (format "%S" `(match_dup ,mode ,n))))
	       (puthash cons t hash2)))))))))

(defun make-all-insns-parallel ()
  (goto-char (point-min))
  (let* ((hash (make-hash-table))
	 (forms (myread hash)))
    (dolist (form forms)
      (pcase form
	(`(,(or 'define_insn 'define_insn_and_split) ,name (vector (parallel .  ,rest1) . ,rest2) . ,rest3)
	  )
	(`(,(or 'define_insn 'define_insn_and_split) ,name ,(and subform `(vector . ,rest1)) . ,rest2)
	 (let* ((ps (gethash subform hash))
		(p0 (car ps))
		(p1 (cdr ps)))
	   (goto-char (+ p0 8))
	   (insert "(parallel (vector ")
	   (goto-char p1)
	   (insert "))")))))))

(defun make-all-insns-serial ()
  (goto-char (point-min))
  (let* ((hash (make-hash-table))
	 (forms (myread hash)))
    (dolist (form forms)
      (pcase form
	(`(,(or 'define_insn 'define_insn_and_split)
	   ,name ,(and v `(vector (parallel . ,rest1))) . ,rest2)
	 (let* ((ps (gethash v hash))
		(p0 (car ps))
		(p1 (cdr ps)))
	   (goto-char (1- p0))
	   (delete-char (length "(vector (parallel "))
 	   (goto-char (- p1 2))
	   (delete-char 2)))))))

(defun convert-rtl-buffer ()
  (make-all-insns-parallel)
  (add-splitters)
  (add-clobbers)
  (add-results)
  (dupify-insns)
  (make-all-insns-serial))

(defun gnurlify (filename)
  (interactive "f")
  (with-temp-buffer
    (display-buffer (current-buffer))
    (insert-file-contents filename)
    (goto-char (point-min))
    (elispify-rtl)
    (goto-char (point-min))
    (elispify-pass-2)
    (goto-char (point-min))
    (mangle-rtl-buffer)
    (convert-rtl-buffer)
    (goto-char (point-min))
    (gnurl-to-rtl)
    (write-file (concat filename ".new"))))
